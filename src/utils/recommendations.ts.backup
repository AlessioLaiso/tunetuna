import type { BaseItemDto } from '../api/types'
import { jellyfinClient } from '../api/jellyfin'
import { useMusicStore } from '../stores/musicStore'

interface RecommendationOptions {
  currentTrack: BaseItemDto
  queue: BaseItemDto[]
  recentQueue: BaseItemDto[]
  lastPlayedTrack?: BaseItemDto | null
}

export async function getRecommendedSongs({
  currentTrack,
  queue,
  recentQueue,
  lastPlayedTrack,
}: RecommendationOptions): Promise<BaseItemDto[]> {
  const isDev = (import.meta as any)?.env?.DEV ?? false
  if (!currentTrack) {
    if (isDev) {
      console.log('[Recommendations] No current track')
    }
    return []
  }

  // Prioritize genre-specific cached songs for efficiency
  const { songs: mainSongs, genreSongs, genres: cachedGenres } = useMusicStore.getState()

  // Get current track's genres
  const currentGenres = currentTrack.Genres || []

  // 1. Try genre-specific songs first (most efficient & relevant)
  let availableSongs: LightweightSong[] = []

  if (currentGenres.length > 0 && cachedGenres.length > 0) {
    // Find all genre IDs that match current track's genres
    const matchingGenreIds = cachedGenres
      .filter(genre =>
        genre.Name && currentGenres.some(trackGenre =>
          trackGenre.toLowerCase() === genre.Name!.toLowerCase()
        )
      )
      .map(genre => genre.Id!)
      .filter(id => genreSongs[id] && genreSongs[id].length > 0)

    if (matchingGenreIds.length > 0) {
      // Safe to flatten since each song only appears in one genre
      availableSongs = matchingGenreIds.flatMap(genreId => genreSongs[genreId])
      if (isDev) console.log(`[Recommendations] Using ${availableSongs.length} pre-filtered songs from ${matchingGenreIds.length} matching genres`)
    }
  }

  // 2. Fall back to main songs array
  if (availableSongs.length === 0 && mainSongs.length > 0) {
    availableSongs = mainSongs
    if (isDev) console.log(`[Recommendations] Using ${availableSongs.length} songs from main cache`)
  }

  // 3. Final fallback: all genre songs flattened
  if (availableSongs.length === 0) {
    const allGenreSongs = Object.values(genreSongs).flat()
    if (allGenreSongs.length > 0) {
      availableSongs = allGenreSongs
      if (isDev) console.log(`[Recommendations] Using ${availableSongs.length} songs from all genre caches`)
    }
  }

  // 4. No cache at all - disable recommendations
  if (availableSongs.length === 0) {
    if (isDev) console.log('[Recommendations] No cached songs available - disabling recommendations')
    const { setShowQueueRecommendations } = useSettingsStore.getState()
    setShowQueueRecommendations(false)
    console.warn("Couldn't generate recommendations. Try syncing your library")
    return []
  }

  // Generate recommendations from available songs
  let recommendations: BaseItemDto[] = []

  const genres = currentTrack.Genres || []

  if (isDev) {
    console.log('[Recommendations] ===== RECOMMENDATIONS =====')
    console.log('[Recommendations] Using', availableSongs.length, 'available songs')
    console.log('[Recommendations] Current track genres:', genres)
  }

  // Enhanced cached-based recommendations with better filtering
  let recommendations: BaseItemDto[] = []

  // 1. Genre matches (highest priority) - include synthetic genres
  if (genres.length > 0) {
    const genreMatches = cachedSongs.filter(song => {
      // Check if song has any of the track's genres (more lenient matching)
      const hasGenreMatch = song.Genres?.some(songGenre =>
        genres.some(trackGenre =>
          songGenre.toLowerCase() === trackGenre.toLowerCase() ||
          songGenre.toLowerCase().includes(trackGenre.toLowerCase()) ||
          trackGenre.toLowerCase().includes(songGenre.toLowerCase())
        )
      )

      // Also accept songs that have any genre at all if we have genres (expand search)
      const hasAnyGenre = song.Genres && song.Genres.length > 0

      const notCurrentTrack = song.Id !== currentTrack.Id
      const notInQueue = !queue.some(queued => queued.Id === song.Id)

      // Allow some recommendations from artists in queue, but limit to avoid clustering
      const queueArtistIds = queue.flatMap(q => q.ArtistItems?.map(a => a.Id) || [])
      const artistSongCount = queueArtistIds.filter(id =>
        song.ArtistItems?.some(songArtist => songArtist.Id === id)
      ).length
      const notOverrepresentedArtist = artistSongCount < 2 // Allow artists with < 2 songs in queue

      return (hasGenreMatch || hasAnyGenre) && notCurrentTrack && notInQueue && notOverrepresentedArtist
    })
    recommendations.push(...genreMatches.slice(0, 8))
    if (isDev) console.log(`[Recommendations] Found ${genreMatches.length} genre matches (lenient matching)`)

    // If we didn't find enough genre matches, add some songs with any genre
    if (genreMatches.length < 4) {
      const anyGenreMatches = cachedSongs.filter(song => {
        const notInRecommendations = !recommendations.some(rec => rec.Id === song.Id)
        const notCurrentTrack = song.Id !== currentTrack.Id
        const notInQueue = !queue.some(queued => queued.Id === song.Id)
        const artistSongCount = queueArtistIds.filter(id =>
          song.ArtistItems?.some(songArtist => songArtist.Id === id)
        ).length
        const notOverrepresentedArtist = artistSongCount < 2

        return notInRecommendations && notCurrentTrack && notInQueue && notOverrepresentedArtist && hasAnyGenre
      })
      const additionalNeeded = Math.min(4 - genreMatches.length, anyGenreMatches.length)
      recommendations.push(...shuffleArray(anyGenreMatches).slice(0, additionalNeeded))
      if (isDev && additionalNeeded > 0) console.log(`[Recommendations] Added ${additionalNeeded} additional songs with any genre`)
    }
  } else {
    if (isDev) console.log('[Recommendations] No genres on current track, skipping genre matching')
  }

  // Skip artist matching - we don't want to prioritize same artist

  // 3. Year matches (if available) - but avoid overrepresented artists
  const currentYear = currentTrack.ProductionYear
  if (currentYear) {
    const queueArtistIds = queue.flatMap(q => q.ArtistItems?.map(a => a.Id) || [])
    const yearMatches = cachedSongs.filter(song => {
      const notInQueue = !queue.some(queued => queued.Id === song.Id)
      const notAlreadyRecommended = !recommendations.some(rec => rec.Id === song.Id)
      const notCurrentTrack = song.Id !== currentTrack.Id
      const artistSongCount = queueArtistIds.filter(id =>
        song.ArtistItems?.some(songArtist => songArtist.Id === id)
      ).length
      const notOverrepresentedArtist = artistSongCount < 2

      return song.ProductionYear === currentYear && notCurrentTrack && notInQueue && notAlreadyRecommended && notOverrepresentedArtist
    })
    recommendations.push(...yearMatches.slice(0, 3))
    if (isDev) console.log(`[Recommendations] Found ${yearMatches.length} year matches (excluding overrepresented artists)`)
  }

  // 4. Fallback: Random songs from same decade if we have too few recommendations
  if (recommendations.length < 6 && currentYear) {
    const decadeStart = Math.floor(currentYear / 10) * 10
    const decadeEnd = decadeStart + 9

    const decadeMatches = cachedSongs.filter(song =>
      song.ProductionYear && song.ProductionYear >= decadeStart && song.ProductionYear <= decadeEnd &&
      song.Id !== currentTrack.Id &&
      !queue.some(queued => queued.Id === song.Id) &&
      !recommendations.some(rec => rec.Id === song.Id)
    )
    const needed = Math.min(6 - recommendations.length, decadeMatches.length)
    recommendations.push(...shuffleArray(decadeMatches).slice(0, needed))
    if (isDev) console.log(`[Recommendations] Added ${needed} decade matches`)
  }

  // If we have very few recommendations, add some random songs as fallback (avoiding overrepresented artists)
  if (recommendations.length < 6 && cachedSongs.length > recommendations.length) {
    const queueArtistIds = queue.flatMap(q => q.ArtistItems?.map(a => a.Id) || [])
    const randomSongs = cachedSongs.filter(song => {
      const notInQueue = !queue.some(queued => queued.Id === song.Id)
      const notAlreadyRecommended = !recommendations.some(rec => rec.Id === song.Id)
      const notCurrentTrack = song.Id !== currentTrack.Id
      const artistSongCount = queueArtistIds.filter(id =>
        song.ArtistItems?.some(songArtist => songArtist.Id === id)
      ).length
      const notOverrepresentedArtist = artistSongCount < 2

      return notCurrentTrack && notInQueue && notAlreadyRecommended && notOverrepresentedArtist
    })
    const needed = Math.min(12 - recommendations.length, randomSongs.length)
    if (needed > 0) {
      const randomPicks = shuffleArray(randomSongs).slice(0, needed)
      recommendations.push(...randomPicks)
      if (isDev) console.log(`[Recommendations] Added ${needed} random songs as fallback (excluding overrepresented artists)`)
    }
  }

  // Final fallback: if we still have no recommendations, return some from the queue
  if (recommendations.length === 0) {
    const queueFallback = queue.filter(song =>
      song.Id !== currentTrack.Id &&
      song.source === 'user'
    )
    if (queueFallback.length > 0) {
      const shuffled = shuffleArray(queueFallback)
      recommendations.push(...shuffled.slice(0, Math.min(6, queueFallback.length)))
      if (isDev) console.log(`[Recommendations] Final fallback: ${recommendations.length} songs from queue`)
    }
  }

  // Shuffle and limit to 12
  const shuffled = shuffleArray(recommendations)
  const finalRecommendations = shuffled.slice(0, 12)

  if (isDev) {
    console.log(`[Recommendations] Generated ${finalRecommendations.length} recommendations from cache`)
    if (finalRecommendations.length > 0) {
      console.log('[Recommendations] Sample recommendations:', finalRecommendations.slice(0, 3).map(r => ({ name: r.Name, id: r.Id })))
    }
  }

  return finalRecommendations
}

// Fisher-Yates shuffle function for proper randomization
function shuffleArray<T>(array: T[]): T[] {
  if (array.length <= 1) return [...array]

  const shuffled = [...array]
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]
  }

  return shuffled
}
